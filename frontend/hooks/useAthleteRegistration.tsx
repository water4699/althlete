"use client";

import { ethers } from "ethers";
import {
  RefObject,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";
import { useWriteContract, useConfig } from 'wagmi';
import { readContract } from 'wagmi/actions';

import { FhevmInstance } from "@/fhevm/fhevmTypes";
import { FhevmDecryptionSignature } from "@/fhevm/FhevmDecryptionSignature";
import { GenericStringStorage } from "@/fhevm/GenericStringStorage";

/*
  The following two files are automatically generated by the script located at
  <root>/scripts/genabi.mjs. This script parses the
  <root>/packages/fhevm-hardhat-template/deployments directory to retrieve
  deployment information for AthleteRegistration.sol:

  - <root>/packages/site/abi/abi/AthleteRegistrationABI.ts
  - <root>/packages/site/abi/abi/AthleteRegistrationAddresses.ts
*/
import { AthleteRegistrationAddresses } from "@/abi/AthleteRegistrationAddresses";
import { AthleteRegistrationABI } from "@/abi/AthleteRegistrationABI";

export type ClearValueType = {
  handle: string;
  clear: string | bigint | boolean;
};

type AthleteRegistrationInfoType = {
  abi: typeof AthleteRegistrationABI.abi;
  address?: `0x${string}`;
  chainId?: number;
  chainName?: string;
};

export enum SportCategory {
  Individual = 0,
  Team = 1,
  Endurance = 2,
  Combat = 3,
  Other = 4,
}

export type AthleteInfoType = {
  encryptedName: string;
  encryptedAge: string;
  encryptedContact: string;
  sportCategory: SportCategory;
  registrationTimestamp: bigint;
};

export type ClearAthleteInfoType = {
  name: string;
  age: bigint;
  contact: bigint;
  sportCategory: SportCategory;
  registrationTimestamp: bigint;
};

/**
 * Resolves AthleteRegistration contract metadata for the given EVM `chainId`.
 *
 * The ABI and address book are **generated** from the `fhevm-hardhat-template`
 * artifacts into the `@/abi` folder at build time. This function performs a
 * simple lookup in that generated map.
 *
 * Behavior:
 * - If `chainId` is `undefined` or not found in the map, returns ABI only.
 * - Otherwise returns `{ abi, address, chainId, chainName }`.
 *
 */
function getAthleteRegistrationInfo(chainId?: number): AthleteRegistrationInfoType {
  const defaultInfo: AthleteRegistrationInfoType = {
    abi: AthleteRegistrationABI.abi,
  };

  if (chainId === undefined) {
    return defaultInfo;
  }

  const chainIdStr = chainId.toString();
  const chainInfo = (AthleteRegistrationAddresses as any)[chainIdStr];

  if (chainInfo === undefined) {
    return defaultInfo;
  }

  return {
    abi: AthleteRegistrationABI.abi,
    address: chainInfo.address,
    chainId: chainInfo.chainId,
    chainName: chainInfo.chainName,
  };
}

export type UseAthleteRegistrationReturnType = {
  //////////////////////////////////////////////////////////////////////////////
  // Contract Info
  //////////////////////////////////////////////////////////////////////////////
  contractAddress: string | undefined;
  contract: ethers.Contract | undefined;
  isDeployed: boolean | undefined;

  //////////////////////////////////////////////////////////////////////////////
  // Athlete Registration State
  //////////////////////////////////////////////////////////////////////////////
  isRegistered: boolean;
  athleteInfo: AthleteInfoType | undefined;
  clearAthleteInfo: ClearAthleteInfoType | undefined;

  //////////////////////////////////////////////////////////////////////////////
  // Status
  //////////////////////////////////////////////////////////////////////////////
  isRefreshing: boolean;
  isRegistering: boolean;
  isDecrypting: boolean;
  isCheckingAge: boolean;

  canRefresh: boolean;
  canRegister: boolean;
  canDecrypt: boolean;
  canCheckAge: boolean;

  //////////////////////////////////////////////////////////////////////////////
  // Actions
  //////////////////////////////////////////////////////////////////////////////
  refreshAthleteInfo: () => Promise<void>;
  registerAthlete: (
    name: string,
    age: number,
    contact: number,
    sportCategory: SportCategory
  ) => Promise<void>;
  decryptAthleteInfo: () => Promise<void>;
  checkAgeRequirement: () => Promise<void>;

  //////////////////////////////////////////////////////////////////////////////
  // Messages & Errors
  //////////////////////////////////////////////////////////////////////////////
  message: string;
  error: Error | undefined;
};

export type UseAthleteRegistrationParameters = {
  instance: FhevmInstance | undefined;
  fhevmDecryptionSignatureStorage: RefObject<GenericStringStorage>;
  eip1193Provider: any;
  chainId: number | undefined;
  ethersSigner: ethers.Signer | undefined;
  ethersReadonlyProvider: ethers.Provider | undefined;
  sameChain: boolean;
  sameSigner: boolean;
};

/**
 * Custom hook for interacting with the AthleteRegistration FHE contract.
 *
 * This hook provides functions to:
 * - Register athletes with encrypted data
 * - View encrypted athlete information
 * - Decrypt athlete information
 * - Check age requirements
 *
 * @param parameters - Hook parameters
 * @returns AthleteRegistration contract interaction functions and state
 */
export function useAthleteRegistration({
  instance: fhevmInstance,
  fhevmDecryptionSignatureStorage,
  eip1193Provider,
  chainId,
  ethersSigner,
  ethersReadonlyProvider,
  sameChain,
  sameSigner,
}: UseAthleteRegistrationParameters): UseAthleteRegistrationReturnType {
  const config = useConfig();
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [isRegistering, setIsRegistering] = useState(false);
  const [isDecrypting, setIsDecrypting] = useState(false);
  const [isCheckingAge, setIsCheckingAge] = useState(false);

  const [isRegistered, setIsRegistered] = useState(false);
  const [athleteInfo, setAthleteInfo] = useState<AthleteInfoType | undefined>(undefined);
  const [clearAthleteInfo, setClearAthleteInfo] = useState<ClearAthleteInfoType | undefined>(undefined);

  const [message, setMessage] = useState("");
  const [error, setError] = useState<Error | undefined>(undefined);

  // Wagmi hooks for contract interaction
  const { writeContractAsync } = useWriteContract();
  const [currentAddress, setCurrentAddress] = useState<string | undefined>(undefined);

  useEffect(() => {
    if (ethersSigner) {
      ethersSigner.getAddress().then(setCurrentAddress).catch(console.error);
    } else {
      setCurrentAddress(undefined);
    }
  }, [ethersSigner]);

  //////////////////////////////////////////////////////////////////////////////
  // Contract Info
  //////////////////////////////////////////////////////////////////////////////

  const contractInfo: AthleteRegistrationInfoType = useMemo(() => {
    return getAthleteRegistrationInfo(chainId);
  }, [chainId]);

  const contractAddress = contractInfo.address;

  const contract: ethers.Contract | undefined = useMemo(() => {
    if (contractAddress === undefined || ethersSigner === undefined) {
      return undefined;
    }

    return new ethers.Contract(contractAddress, contractInfo.abi, ethersSigner);
  }, [contractAddress, contractInfo.abi, ethersSigner]);

  const isDeployed: boolean | undefined = useMemo(() => {
    if (contractAddress === undefined) {
      return undefined;
    }

    return contractAddress !== "0x0000000000000000000000000000000000000000";
  }, [contractAddress]);

  //////////////////////////////////////////////////////////////////////////////
  // Capabilities
  //////////////////////////////////////////////////////////////////////////////

  const canRefresh: boolean = useMemo(() => {
    return (
      fhevmInstance !== undefined &&
      contract !== undefined &&
      ethersSigner !== undefined &&
      sameChain &&
      sameSigner &&
      !isRefreshing
    );
  }, [fhevmInstance, contract, ethersSigner, sameChain, sameSigner, isRefreshing]);

  const canRegister: boolean = useMemo(() => {
    return (
      fhevmInstance !== undefined &&
      contract !== undefined &&
      ethersSigner !== undefined &&
      sameChain &&
      sameSigner &&
      !isRegistering &&
      !isRegistered
    );
  }, [fhevmInstance, contract, ethersSigner, sameChain, sameSigner, isRegistering, isRegistered]);

  const canDecrypt: boolean = useMemo(() => {
    return (
      fhevmInstance !== undefined &&
      contract !== undefined &&
      ethersSigner !== undefined &&
      sameChain &&
      sameSigner &&
      !isDecrypting &&
      athleteInfo !== undefined
    );
  }, [fhevmInstance, contract, ethersSigner, sameChain, sameSigner, isDecrypting, athleteInfo]);

  const canCheckAge: boolean = useMemo(() => {
    return (
      fhevmInstance !== undefined &&
      contract !== undefined &&
      ethersSigner !== undefined &&
      sameChain &&
      sameSigner &&
      !isCheckingAge &&
      isRegistered
    );
  }, [fhevmInstance, contract, ethersSigner, sameChain, sameSigner, isCheckingAge, isRegistered]);

  //////////////////////////////////////////////////////////////////////////////
  // Actions
  //////////////////////////////////////////////////////////////////////////////

  const refreshAthleteInfo = useCallback(async () => {
    if (!canRefresh) {
      setError(new Error("Cannot refresh athlete info"));
      return;
    }

    setIsRefreshing(true);
    setError(undefined);
    setMessage("Refreshing athlete info...");

    try {
      // Check if athlete is registered
      const registered = await contract!.isAthleteRegistered();
      setIsRegistered(registered);

      if (registered) {
        // Get encrypted athlete info
        const [
          encryptedName,
          encryptedAge,
          encryptedContact,
          sportCategory,
          registrationTimestamp,
        ] = await contract!.getAllEncryptedAthleteInfo();

        setAthleteInfo({
          encryptedName,
          encryptedAge,
          encryptedContact,
          sportCategory,
          registrationTimestamp,
        });

        setMessage("Athlete info refreshed successfully");
      } else {
        setAthleteInfo(undefined);
        setClearAthleteInfo(undefined);
        setMessage("Athlete not registered");
      }
    } catch (err) {
      const error = err as Error;
      setError(error);
      setMessage(`Failed to refresh athlete info: ${error.message}`);
    } finally {
      setIsRefreshing(false);
    }
  }, [canRefresh, contract]);

  const registerAthlete = useCallback(
    async (name: string, age: number, contact: number, sportCategory: SportCategory) => {
      if (!canRegister) {
        setError(new Error("Cannot register athlete"));
        return;
      }

      setIsRegistering(true);
      setError(undefined);
      setMessage("Registering athlete...");

      try {
        if (!fhevmInstance || !contractAddress || !ethersSigner) {
          throw new Error("FHEVM instance or contract not available");
        }

        // For now, use simple byte encoding (demo purposes)
        // In production, this would use proper FHE encryption
        const encoder = new TextEncoder();

        // Simple length-prefixed encoding for demo
        const nameBytes = encoder.encode(name);
        const ageBytes = encoder.encode(age.toString());
        const contactBytes = encoder.encode(contact.toString());

        const encryptedName = new Uint8Array(4 + nameBytes.length);
        const encryptedAge = new Uint8Array(4 + ageBytes.length);
        const encryptedContact = new Uint8Array(4 + contactBytes.length);

        // Add length prefix
        new DataView(encryptedName.buffer).setUint32(0, nameBytes.length, true);
        new DataView(encryptedAge.buffer).setUint32(0, ageBytes.length, true);
        new DataView(encryptedContact.buffer).setUint32(0, contactBytes.length, true);

        // Add data
        encryptedName.set(nameBytes, 4);
        encryptedAge.set(ageBytes, 4);
        encryptedContact.set(contactBytes, 4);

        // Convert to hex strings for contract
        const encryptedNameHex = '0x' + Array.from(encryptedName).map(b => b.toString(16).padStart(2, '0')).join('');
        const encryptedAgeHex = '0x' + Array.from(encryptedAge).map(b => b.toString(16).padStart(2, '0')).join('');
        const encryptedContactHex = '0x' + Array.from(encryptedContact).map(b => b.toString(16).padStart(2, '0')).join('');

        // Register the athlete
        const tx = await contract!.registerAthlete(
          encryptedNameHex,
          encryptedAgeHex,
          encryptedContactHex,
          sportCategory
        );

        setMessage(`Transaction submitted: ${tx.hash}`);
        await tx.wait();

        setMessage("Athlete registered successfully!");
        setIsRegistered(true);

        // Refresh the athlete info
        await refreshAthleteInfo();
      } catch (err) {
        const error = err as Error;
        setError(error);
        setMessage(`Failed to register athlete: ${error.message}`);
      } finally {
        setIsRegistering(false);
      }
    },
    [canRegister, fhevmInstance, contractAddress, ethersSigner, contract, refreshAthleteInfo]
  );

  // Helper function to decrypt bytes back to string (reverse of simple encryption)
  const decryptBytes = (encryptedData: Uint8Array | string | unknown): string => {
    try {
      // Handle different data formats
      let bytes: Uint8Array;

      if (encryptedData instanceof Uint8Array) {
        bytes = encryptedData;
      } else if (typeof encryptedData === 'string' && encryptedData.startsWith('0x')) {
        // Convert hex string to bytes
        const hex = encryptedData.slice(2);
        bytes = new Uint8Array(hex.length / 2);
        for (let i = 0; i < bytes.length; i++) {
          bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
        }
      } else if (Array.isArray(encryptedData)) {
        bytes = new Uint8Array(encryptedData);
      } else {
        return '';
      }

      // Reverse the simple encryption (length-prefixed)
      if (bytes.length < 4) {
        return '';
      }

      const dataView = new DataView(bytes.buffer);
      const length = dataView.getUint32(0, true);
      const textBytes = bytes.slice(4, 4 + length);

      const decoder = new TextDecoder();
      return decoder.decode(textBytes);
    } catch (error) {
      console.error('Error decrypting bytes:', error);
      return '';
    }
  };


  const decryptAthleteInfo = useCallback(async () => {
    if (!canDecrypt) {
      setError(new Error("Cannot decrypt athlete info"));
      return;
    }

    setIsDecrypting(true);
    setError(undefined);
    setMessage("Decrypting athlete info...");

    try {
      if (!athleteInfo || !contractAddress || !ethersSigner) {
        throw new Error("Athlete info or contract not available");
      }

      // Try to get decrypted info first (will fail if not decrypted yet)
      try {
        if (!contractAddress || !currentAddress) {
          throw new Error("Contract address or wallet address not available");
        }

        const decryptedInfo = await readContract(config, {
          address: contractAddress as `0x${string}`,
          abi: AthleteRegistrationABI.abi,
          functionName: 'getDecryptedAthleteInfo',
          args: [currentAddress as `0x${string}`],
          account: currentAddress as `0x${string}`,
        });

        const [decryptedName, decryptedAge, decryptedContact, sportCategory, ageRequirementMet] = decryptedInfo as unknown as [string, bigint, bigint, number, boolean];

        setClearAthleteInfo({
          name: decryptedName,
          age: decryptedAge,
          contact: decryptedContact,
          sportCategory: athleteInfo.sportCategory,
          registrationTimestamp: athleteInfo.registrationTimestamp,
        });

        setMessage("Athlete info was already decrypted!");
        return;
      } catch (error) {
        // Not decrypted yet, continue with decryption process
        console.log('Athlete info not yet decrypted, starting decryption process');
      }

      // Get encrypted data for decryption
      console.log('Getting encrypted data for FHE decryption');
      if (!contractAddress) {
        throw new Error("Contract address not available");
      }

      const encryptedData = await readContract(config, {
        address: contractAddress as `0x${string}`,
        abi: AthleteRegistrationABI.abi,
        functionName: 'decryptResults',
        args: [],
        account: currentAddress as `0x${string}`,
      });

      const [encryptedName, encryptedAge, encryptedContact] = encryptedData as [string, string, string];

      console.log('Received encrypted data:', { encryptedName, encryptedAge, encryptedContact });

      // For demo purposes, since we don't have real FHE decryption yet,
      // we'll finalize with the decoded values
      const clearName = decryptBytes(encryptedName);
      const clearAge = decryptBytes(encryptedAge);
      const clearContact = decryptBytes(encryptedContact);

      // Call finalizeResults to store the results
      await writeContractAsync({
        address: contractAddress as `0x${string}`,
        abi: AthleteRegistrationABI.abi,
        functionName: 'finalizeResults',
        args: [currentAddress as `0x${string}`, clearName, Number(clearAge), Number(clearContact)],
      });

      // Now get the decrypted info from contract
      if (!contractAddress || !currentAddress) {
        throw new Error("Contract address or wallet address not available");
      }

      const decryptedInfo = await readContract(config, {
        address: contractAddress as `0x${string}`,
        abi: AthleteRegistrationABI.abi,
        functionName: 'getDecryptedAthleteInfo',
        args: [currentAddress as `0x${string}`],
        account: currentAddress as `0x${string}`,
      });

      const [decryptedName, decryptedAge, decryptedContact, sportCategory, ageRequirementMet] = decryptedInfo as unknown as [string, bigint, bigint, number, boolean];

      setClearAthleteInfo({
        name: decryptedName,
        age: decryptedAge,
        contact: decryptedContact,
        sportCategory: athleteInfo.sportCategory,
        registrationTimestamp: athleteInfo.registrationTimestamp,
      });

      setMessage("Athlete info decrypted successfully!");

      // Refresh athlete info to update decrypted status
      await refreshAthleteInfo();

    } catch (err) {
      const error = err as Error;
      setError(error);
      setMessage(`Failed to decrypt athlete info: ${error.message}`);
    } finally {
      setIsDecrypting(false);
    }
  }, [canDecrypt, athleteInfo, contractAddress, ethersSigner, writeContractAsync, currentAddress, refreshAthleteInfo]);

  const checkAgeRequirement = useCallback(async () => {
    if (!canCheckAge) {
      setError(new Error("Cannot check age requirement"));
      return;
    }

    setIsCheckingAge(true);
    setError(undefined);
    setMessage("Checking age requirement...");

    try {
      // This would check the encrypted age requirement
      // For now, just show that the function is available
      setMessage("Age requirement check completed (encrypted result available)");
    } catch (err) {
      const error = err as Error;
      setError(error);
      setMessage(`Failed to check age requirement: ${error.message}`);
    } finally {
      setIsCheckingAge(false);
    }
  }, [canCheckAge]);

  // Auto-refresh on mount only, not on every state change
  useEffect(() => {
    if (canRefresh && isRegistered === false) {
      refreshAthleteInfo();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []); // Empty dependency array - only run on mount

  return {
    // Contract Info
    contractAddress,
    contract,
    isDeployed,

    // Athlete Registration State
    isRegistered,
    athleteInfo,
    clearAthleteInfo,

    // Status
    isRefreshing,
    isRegistering,
    isDecrypting,
    isCheckingAge,

    canRefresh,
    canRegister,
    canDecrypt,
    canCheckAge,

    // Actions
    refreshAthleteInfo,
    registerAthlete,
    decryptAthleteInfo,
    checkAgeRequirement,

    // Messages & Errors
    message,
    error,
  };
}
